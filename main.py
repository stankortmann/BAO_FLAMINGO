import yaml
import numpy as np
import argparse

# Our own modules
import baoflamingo.data_structure as ds
from baoflamingo.pipeline_single import run_pipeline_single
from baoflamingo.plotting import correlation_plotter 


############-------ACTUAL RUNNING, DO NOT DELETE!!! -------#############

if __name__ == "__main__":

      # --- Argument parser ---
    parser = argparse.ArgumentParser(description="Run BAOflamingo PyCorr pipeline")
    parser.add_argument(
        "--config",
        type=str,
        default="configurations/config_pycorr.yaml",
        help="Path to the YAML configuration file"
    )
    args=parser.parse_args()
    # --- Load YAML config file ---
    with open(args.config, "r") as f:
        cfg_dict = yaml.safe_load(f)

    # Create config object
    cfg = ds.Config(
        paths=ds.Paths(**cfg_dict['paths']),
        slicing=ds.Slicing(**cfg_dict['slicing']),
        random_catalog=ds.RandomCatalog(**cfg_dict['random_catalog']),
        filters=ds.Filters(**cfg_dict['filters']),
        plotting=ds.Plotting(**cfg_dict['plotting']),
        statistics=ds.Statistics(**cfg_dict['statistics']),
        fiducial=ds.Fiducial(**cfg_dict['fiducial'])
    )



    # --- Handle multiple snapshot numbers ---
    snapshot_numbers = cfg.paths.snapshot_number
    # Ensure it's always iterable
    if isinstance(snapshot_numbers, int):
        snapshot_numbers = [snapshot_numbers]

    print(f"Found snapshot numbers: {snapshot_numbers}", flush=True)

    # --- Run pipeline for each snapshot ---
    for snap in snapshot_numbers:
        print(f"\n=== Running for snapshot {snap} ===", flush=True)
        cfg.paths.snapshot_number = snap  # update for this iteration

        
        data_filenames = run_pipeline_single(cfg)


        for data_filename in data_filenames:
            print(f"Generating plots for {data_filename}...", flush=True)
            try:
                plotter = correlation_plotter(
                    filename=data_filename,
                    cfg=cfg,
                    mu_rebin=1,
                    s_rebin=1
                )
            except RuntimeError as e:
                # Check if this is the curve_fit maxfev error
                if "Optimal parameters not found" in str(e):
                    print(f"WARNING: Gaussian fit failed for {data_filename}. Deleting output files...", flush=True)

                    # Delete the HDF5 file if it exists
                    if os.path.exists(data_filename):
                        os.remove(data_filename)
                        print(f"Deleted HDF5 file: {data_filename}", flush=True)

                    # Delete the figure(s) generated by this plotter
                    # Assuming plotter writes fig files to cfg.paths.output or similar
                    fig_dir = cfg.paths.output  # adjust if needed
                    # Use same base name as data_filename to match figure
                    base_name = os.path.splitext(os.path.basename(data_filename))[0]
                    for ext in [".png", ".pdf"]:
                        fig_path = os.path.join(fig_dir, f"{base_name}{ext}")
                        if os.path.exists(fig_path):
                            os.remove(fig_path)
                            print(f"Deleted figure: {fig_path}", flush=True)
                else:
                    # Re-raise other RuntimeErrors
                    raise
    print("\nAll snapshots processed successfully.")


